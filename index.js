const path = require('path')
const WexExtManifestPlugin = require('./lib/WexExtManifestPlugin')

module.exports = (opts = {}) => neutrino => {
  const argv = require('yargs-parser')(process.argv.slice(2))
  const isDev = process.env.NODE_ENV === 'development'
  const isProd = process.env.NODE_ENV === 'production'

  const options = {
    polyfill: false,
    template: path.resolve(__dirname, 'template.ejs'),
    manifest: path.resolve(neutrino.options.root, 'src', 'manifest'),
    ...opts
  }

  if (!path.isAbsolute(options.manifest)) {
    options.manifest = path.resolve(neutrino.options.root, options.manifest)
  }

  const backgroundEntry = Object.keys(neutrino.options.mains).find(name => {
    const { webext } = neutrino.options.mains[name]
    return webext && webext.type === 'background'
  })

  Object.entries(neutrino.options.mains).forEach(([name, { webext }]) => {
    if (isProd) {
      if (
        webext &&
        webext.type &&
        /^(content_scripts|background|pageless)$/.test(webext.type)
      ) {
        // remove plugins generated by web preset
        neutrino.config.plugins.delete(`html-${name}`)
        return
      }

      if (options.polyfill) {
        neutrino.config.plugin(`html-${name}`).tap(args => {
          if (args[0]) {
            args[0].webextPolyfill = options.polyfill
            args[0].template = options.template
          }
          return args
        })
      }
    }

    if (isDev) {
      // if you want to keep all the entries but open to a specific path
      // use webpack-dev-server cli option --open-page [entry name].html
      if (argv.wextentry && argv.wextentry !== name) {
        neutrino.config.entryPoints.delete(name)
        neutrino.config.plugins.delete(`html-${name}`)
        return
      }

      if (backgroundEntry === name) {
        neutrino.config
          .entry(name)
          .when(options.polyfill, config =>
            config.prepend('webextension-polyfill')
          )
          .prepend(require.resolve('webextensions-emulator/dist/background'))
          .end()
          .plugins.delete(`html-${name}`)
      } else {
        neutrino.config
          .entry(name)
          .when(options.polyfill, config =>
            config.prepend('webextension-polyfill')
          )
          .prepend(require.resolve('webextensions-emulator/dist/core'))
          .end()
          .plugin(`html-${name}`)
          .when(backgroundEntry, plugin =>
            plugin.tap(args => {
              if (args[0]) {
                args[0].inject = false // manual inject
                args[0].webextBackground = backgroundEntry
                args[0].chunks.push(backgroundEntry)
                args[0].template = path.resolve(__dirname, 'template.dev.ejs')
              }
              return args
            })
          )
      }
    }
  })

  if (isDev) {
    const entry = argv.wextentry
      ? argv.wextentry
      : Object.keys(neutrino.options.mains).find(
        entry => entry !== backgroundEntry
      )
    neutrino.config.optimization
      .clear()
      .end()
      .devServer.index(`${entry}.html`)
  }

  if (isProd) {
    neutrino.config
      .plugin('webext')
      .use(WexExtManifestPlugin, [options, neutrino.options])
  }

  if (neutrino.config.module.rules.has('lint')) {
    neutrino.config.module
      .rule('lint')
      .use('eslint')
      .tap(options => {
        if (!options.globals) {
          options.globals = ['browser']
        } else if (options.globals.length != null) {
          options.globals.push('browser')
        } else {
          options.globals.browser = true
        }
        return options
      })
  }
}
